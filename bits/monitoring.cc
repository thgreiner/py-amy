#include "monitoring.h"

namespace monitoring {

monitoring *monitoring::single_instance = 0;

void monitoring::setup(void) {

    registry = std::make_shared<prometheus::Registry>();
    exposer.RegisterCollectable(registry);

    auto &nodes_counter = prometheus::BuildCounter()
                              .Name("nodes_total")
                              .Help("Nodes visited")
                              .Register(*registry)
                              .Add({{"instance", "selfplay "}});

    observe_node = [&nodes_counter]() { nodes_counter.Increment(); };

    auto &terminal_nodes_counter = prometheus::BuildCounter()
                                       .Name("terminal_nodes_total")
                                       .Help("Terminal nodes visited")
                                       .Register(*registry)
                                       .Add({{"instance", "selfplay "}});

    observe_terminal_node = [&terminal_nodes_counter]() {
        terminal_nodes_counter.Increment();
    };

    auto &games_counter = prometheus::BuildCounter()
                              .Name("games_total")
                              .Help("Games played by selfplay")
                              .Register(*registry)
                              .Add({});

    observe_game = [&games_counter]() { games_counter.Increment(); };

    auto &positions_counter = prometheus::BuildCounter()
                                  .Name("positions_total")
                                  .Help("Positions generated by selfplay")
                                  .Register(*registry)
                                  .Add({});

    observe_position = [&positions_counter]() {
        positions_counter.Increment();
    };

    auto &checkmate_counter = prometheus::BuildCounter()
                                  .Name("checkmate_total")
                                  .Help("Winning moves by forced checkmate")
                                  .Register(*registry)
                                  .Add({});

    observe_checkmate = [&checkmate_counter]() {
        checkmate_counter.Increment();
    };

    auto &tbwinner_counter = prometheus::BuildCounter()
                                 .Name("tbwinner_total")
                                 .Help("Winning moves found in the TBs")
                                 .Register(*registry)
                                 .Add({});

    observe_tbwinner = [&tbwinner_counter]() { tbwinner_counter.Increment(); };

    auto &evaluation_gauge = prometheus::BuildGauge()
                                 .Name("white_prob")
                                 .Help("Win probability white")
                                 .Register(*registry)
                                 .Add({});

    observe_evaluation = [&evaluation_gauge](double eval) {
        evaluation_gauge.Set(eval);
    };

    std::vector<double> depth_buckets({1,  2,  3,  4,  5,  6,  7,  8,
                                       9,  10, 12, 14, 16, 18, 20, 24,
                                       28, 32, 36, 40, 48, 56, 64});

    auto &depth_histogram = prometheus::BuildHistogram()
                                .Name("depth")
                                .Help("Search depth")
                                .Register(*registry)
                                .Add({}, depth_buckets);

    observe_depth = [&depth_histogram](int depth) {
        depth_histogram.Observe(depth);
    };

    std::vector<double> decision_buckets(
        {10,   20,   40,   60,   80,   100,  140,   180,  220, 260,
         300,  350,  400,  450,  500,  600,  700,   800,  900, 1000,
         1500, 2000, 3000, 4000, 5000, 8000, 10000, 20000});

    auto &decision_histogram = prometheus::BuildHistogram()
                                   .Name("decision")
                                   .Help("Decision iteration")
                                   .Register(*registry)
                                   .Add({}, decision_buckets);

    observe_decision = [&decision_histogram](int decision) {
        decision_histogram.Observe(decision);
    };
}
} // namespace monitoring
