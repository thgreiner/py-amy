#!/usr/bin/env python3

import chess.pgn
import argparse
import random
import time

from chess import Board
from datetime import date
import pos_generator
from network import load_or_create_model
from mcts import MCTS, select_root_move
from prometheus_client import start_http_server, Counter

MAX_HALFMOVES_IN_GAME = 200

def format_root_moves(root, board):
    if root.visit_count == 0:
        return None

    root_moves = []
    for key, val in root.children.items():
        prop = val.visit_count / root.visit_count
        if prop >= 1e-3:
            root_moves.append("{}:{:.3f}".format(board.san(key), prop))

    return "q={:.3f}; p=[{}]".format(
        1.0 - root.value(),
        ", ".join(root_moves))

def create_node_with_comment(node, tree, best_move, board, pos_counter ,follow_main_line=False):
    new_node = node.add_main_variation(best_move)
    new_node.comment = format_root_moves(tree, board)

    if new_node.comment:
        pos_counter.inc()

    # for move, subtree in tree.children.items():
    #     if not follow_main_line and move == best_move: continue
    #
    #     if subtree.visit_count > 100:  # arbitrary threshold
    #         if follow_main_line and move == best_move:
    #             tmp_node = new_node
    #         else:
    #             tmp_node = node.add_variation(move)
    #         board.push(move)
    #         tmp_best_move = select_root_move(subtree, board.fullmove_number, False)
    #         if tmp_best_move is not None:
    #             create_node_with_comment(tmp_node, subtree, tmp_best_move, board, pos_counter, True)
    #         board.pop()

    return new_node

# not really nice here...
start_http_server(9099)
pos_counter = Counter('positions_total', "Positions generated by selfplay")
game_counter = Counter('games_total', 'Games played by selfplay')

class DefaultGameSaver:
    def __init__(self):
        self.name = "MatchGames-{}.pgn".format(time.strftime('%Y-%m-%d-%H-%M-%S'))

    def __call__(self, game):
        with open(self.name, "a") as f:
            exporter = chess.pgn.FileExporter(f)
            game.accept(exporter)


def matchplay(model1, model2, num_simulations, verbose=True, prefix="0", generator=None, saver=DefaultGameSaver()):

    mcts1 = MCTS(model1, verbose, prefix, exploration_noise=False, max_simulations=num_simulations)
    mcts1.set_delta_selection_strategy()

    mcts2 = MCTS(model2, verbose, prefix, exploration_noise=False, max_simulations=num_simulations)
    mcts2.set_delta_selection_strategy()

    total_positions = 0

    while total_positions < 1638400:

        player1 = "Amy Zero [{}]".format(model1.name)
        player2 = "Amy Zero [{}]".format(model2.name)

        game = chess.pgn.Game()
        game.headers["Event"] = "Test Game"
        game.headers["White"] = player1
        game.headers["Black"] = player2
        game.headers["Date"] = date.today().strftime("%Y.%m.%d")
        node = game

        board = Board()

        while not board.is_game_over(claim_draw = True) and board.halfmove_clock < MAX_HALFMOVES_IN_GAME:
            if board.turn:
                best_move, tree = mcts1.mcts(board, prefix=prefix)
            else:
                best_move, tree = mcts2.mcts(board, prefix=prefix)

            node = create_node_with_comment(node, tree, best_move, board, pos_counter)

            board.push(best_move)

            if node.comment:
                total_positions += 1

        game.headers["Result"] = board.result(claim_draw=True)
        saver(game)

        game_counter.inc()

        mcts1, mcts2 = mcts2, mcts1

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Self play.")
    parser.add_argument('--sims', type=int, help="number of simulations", default=5000)
    parser.add_argument('--model1', help="model1 file name")
    parser.add_argument('--model2', help="model2 file name")

    args = parser.parse_args()


    model1 = load_or_create_model(args.model1)
    model2 = load_or_create_model(args.model2)

    matchplay(model1, model2, args.sims)
